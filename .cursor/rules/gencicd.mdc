---
description: When user request to trigger workflow generation, generate workflow for current repo, create CI/CD pipeline for current repo, run workflow generation or any similar request to generate workflows
alwaysApply: false
---

# Cursor Rules for Agentic CI/CD Workflow Generation

## Overview

This project uses an orchestrator Lambda function to generate GitHub Actions workflows for repositories. The orchestrator coordinates multiple Bedrock agents to analyze repositories, design pipelines, and create pull requests.

## Workflow Generation Trigger

When the user requests to:

- "trigger workflow generation"
- "generate workflow for [repo URL]"
- "create CI/CD pipeline for [repo]"
- "run workflow generation"
- Any similar request to generate workflows

### Required Steps:

1. **Get Terraform Outputs**

   - Run `terraform output -json` to get all outputs
   - Extract `lambda_orchestrator` (orchestrator Lambda function name)
   - Extract `agent_ids_map` (JSON object with agent IDs)
   - Extract `dynamodb_table` (DynamoDB table name for tracking)
   - Verify outputs exist before proceeding

2. **Validate Repository URL**

   - Accept GitHub repository URLs in formats:
     - `https://github.com/owner/repo`
     - `git@github.com:owner/repo`
   - Extract owner and repo name from URL
   - Default branch is "main" if not specified

3. **Generate Task ID**

   - Format: `workflow-gen-{timestamp}-{random-hex}`
   - Use `date +%s` for timestamp
   - Use `openssl rand -hex 4` or similar for random component

4. **Create Payload**

   - Example Structure:
     ```json
     {
       "task_id": "workflow-gen-1234567890-abc123",
       "repo_url": "https://github.com/owner/repo",
       "branch": "main",
       "agent_ids": {
         "repo_scanner": "agent-id-1",
         "pipeline_designer": "agent-id-2",
         "security_compliance": "agent-id-3",
         "yaml_generator": "agent-id-4",
         "pr_manager": "agent-id-5"
       }
     }
     ```
   - The `agent_ids` must match the structure from Terraform output `agent_ids_map`

5. **Invoke Orchestrator Lambda**

   - Use AWS CLI: `aws lambda invoke`
   - Function name: from `terraform output -raw lambda_orchestrator`
   - Invocation type: `Event` (asynchronous)
   - CLI binary format: `raw-in-base64-out`
   - Payload: JSON string of the payload created above

6. **Monitor Progress (Optional)**
   - Poll DynamoDB table for task status
   - Table name: from `terraform output -raw dynamodb_table`
   - Key: `{"task_id": {"S": "<task_id>"}}`
   - Check `status` field: "in_progress", "completed", or "failed"
   - Check `result` field for step-by-step progress
   - Expected workflow steps in order:
     1. repo_ingestor
     2. repo_scanner
     3. static_analyzer
     4. pipeline_designer
     5. security_compliance
     6. yaml_generator_ci_attempt_1 (may have attempt_2, attempt_3 if retries occur)
     7. yaml_generator_cd_attempt_1 (may have attempt_2, attempt_3 if retries occur)
     8. pr_manager
     9. github_operations
   - Note: `template_validator` is called internally during YAML generation but is not a separate tracked step
   - Note: YAML generation has separate CI and CD workflows, each with up to 3 retry attempts

## Implementation Guidelines

### Preferred Method: Python Script

Use the Python helper script for easier execution:

```bash
python3 scripts/trigger_workflow_generation.py <repo_url> [--branch <branch>] [--monitor]
```

Or import and use programmatically:

```python
from scripts.trigger_workflow_generation import trigger_workflow_generation
result = trigger_workflow_generation("https://github.com/owner/repo", branch="main", monitor=True)
```

### Alternative Method: Direct AWS CLI

If Python script is not available, use AWS CLI directly after getting Terraform outputs.

### Prerequisites Check

Before triggering workflow generation, verify:

- AWS CLI is installed and configured
- AWS credentials are valid (check with `aws sts get-caller-identity`)
- Terraform is installed
- Terraform outputs are available (`terraform output -json`)
- boto3 Python library (if using Python script: `pip install boto3`)

### Error Handling

- If Terraform outputs are missing, inform user to run `terraform apply` first
- If AWS credentials are invalid, prompt user to configure them
- If Lambda invocation fails, show the error message
- If task fails, extract error from DynamoDB result field

### Task ID Generation

```bash
# Preferred method
TASK_ID="workflow-gen-$(date +%s)-$(openssl rand -hex 4)"

# Fallback if openssl not available
TASK_ID="workflow-gen-$(date +%s)-$(head -c 4 /dev/urandom | od -An -tx1 | tr -d ' \n')"
```

### Lambda Invocation Command

```bash
aws lambda invoke \
  --function-name "$LAMBDA_ORCHESTRATOR" \
  --invocation-type Event \
  --cli-binary-format raw-in-base64-out \
  --payload "$PAYLOAD" \
  /tmp/orchestrator_response_${TASK_ID}.json
```

### DynamoDB Query for Status

```bash
aws dynamodb get-item \
  --table-name "$TABLE_NAME" \
  --key "{\"task_id\": {\"S\": \"$TASK_ID\"}}" \
  --output json
```

### Progress Monitoring

- Parse `result` field (JSON string) from DynamoDB item
- Extract `steps` array from result
- Each step has: `step` (name) and `result` (object with `status`)
- Status values: "success", "error", or "in_progress"

## Example User Prompts and Responses

### Example 1: Simple Request

**User:** "Generate workflow for https://github.com/user/repo"

**Response:**

1. Check prerequisites
2. Get Terraform outputs
3. Generate task ID
4. Invoke orchestrator Lambda
5. Display: "âœ“ Workflow generation triggered for https://github.com/user/repo (branch: main)"
6. Show task ID for tracking

### Example 2: With Branch

**User:** "Create CI/CD pipeline for https://github.com/owner/repo on branch develop"

**Response:**

1. Extract branch "develop" from request
2. Follow same steps as Example 1
3. Use branch "develop" in payload

### Example 3: With Monitoring

**User:** "Trigger workflow generation for https://github.com/user/repo and monitor progress"

**Response:**

1. Trigger workflow generation
2. Poll DynamoDB every 5 seconds
3. Display real-time progress
4. Show final status when complete

### Implementation Steps for AI Assistant

When user requests workflow generation:

1. **Parse the request:**

   - Extract repository URL (required)
   - Extract branch name (optional, default: "main")
   - Check if monitoring is requested

2. **Execute using Python script (preferred):**

   ```python
   import subprocess
   cmd = ["python3", "scripts/trigger_workflow_generation.py", repo_url]
   if branch != "main":
       cmd.extend(["--branch", branch])
   if monitor:
       cmd.append("--monitor")
   subprocess.run(cmd)
   ```

3. **Or execute using AWS CLI:**

   - Get Terraform outputs
   - Generate task ID
   - Create payload JSON
   - Invoke Lambda function
   - Optionally poll DynamoDB

4. **Display results:**
   - Task ID
   - Repository and branch
   - Invocation status
   - Instructions for tracking progress

## Response Format

After triggering:

1. Confirm task ID generated
2. Show repository and branch being processed
3. Confirm Lambda invocation was successful
4. Provide task ID for tracking
5. Optionally offer to monitor progress
6. Inform user that process takes 5-15 minutes

## Agent IDs Mapping

The orchestrator expects these agent IDs in the payload:

- `repo_scanner`: Repository Scanner Agent
- `pipeline_designer`: Pipeline Designer Agent
- `security_compliance`: Security & Compliance Agent
- `yaml_generator`: YAML Generator Agent
- `pr_manager`: PR Manager Agent

Note: The Terraform output `agent_ids_map` includes a `feedback` agent, but the orchestrator only uses the 5 agents listed above.

## DynamoDB Table Structure

Task record structure:

- Primary key: `task_id` (String)
- Attributes:
  - `status` (String): "in_progress", "completed", "failed"
  - `repo_url` (String): Repository URL
  - `result` (String): JSON string with workflow steps and results
  - `created_at` (String): ISO timestamp
  - `updated_at` (String): ISO timestamp

## Notes

- The orchestrator Lambda runs asynchronously (Event invocation type)
- Workflow generation typically takes 5-15 minutes
- The orchestrator coordinates multiple agents and Lambda functions
- Final result includes a GitHub pull request with generated workflow files
- All artifacts are stored in S3 bucket (from Terraform output `s3_bucket`)
